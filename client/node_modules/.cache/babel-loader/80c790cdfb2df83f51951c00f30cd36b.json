{"ast":null,"code":"import _objectSpread from \"/home/oyewoas/Documents/Software Dev Learning/With Companies/LevelUp Academy/Software Dev Projects/github/levelup-timeoffapp/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/home/oyewoas/Documents/Software Dev Learning/With Companies/LevelUp Academy/Software Dev Projects/github/levelup-timeoffapp/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/oyewoas/Documents/Software Dev Learning/With Companies/LevelUp Academy/Software Dev Projects/github/levelup-timeoffapp/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/oyewoas/Documents/Software Dev Learning/With Companies/LevelUp Academy/Software Dev Projects/github/levelup-timeoffapp/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport validator from 'validator';\n\nvar FormValidator =\n/*#__PURE__*/\nfunction () {\n  function FormValidator(validations) {\n    _classCallCheck(this, FormValidator);\n\n    // validations is an array of validation rules specific to a form\n    this.validations = validations;\n  }\n\n  _createClass(FormValidator, [{\n    key: \"validate\",\n    value: function validate(state) {\n      // start out assuming valid\n      var validation = this.valid(); // for each validation rule\n\n      this.validations.forEach(function (rule) {\n        // if the field hasn't already been marked invalid by an earlier rule\n        if (!validation[rule.field].isInvalid) {\n          // determine the field value, the method to invoke and optional args from \n          // the rule definition\n          var field_value = state[rule.field].toString();\n          var args = rule.args || [];\n          var validation_method = typeof rule.method === 'string' ? validator[rule.method] : rule.method; // call the validation_method with the current field value as the first\n          // argument, any additional arguments, and the whole state as a final\n          // argument.  If the result doesn't match the rule.validWhen property,\n          // then modify the validation object for the field and set the isValid\n          // field to false\n\n          if (validation_method.apply(void 0, [field_value].concat(_toConsumableArray(args), [state])) !== rule.validWhen) {\n            validation[rule.field] = {\n              isInvalid: true,\n              message: rule.message\n            };\n            validation.isValid = false;\n          }\n        }\n      });\n      return validation;\n    }\n  }, {\n    key: \"valid\",\n    value: function valid() {\n      var validation = {};\n      this.validations.map(function (rule) {\n        return validation[rule.field] = {\n          isInvalid: false,\n          message: ''\n        };\n      });\n      return _objectSpread({\n        isValid: true\n      }, validation);\n    }\n  }]);\n\n  return FormValidator;\n}();\n\nexport default FormValidator;","map":{"version":3,"sources":["/home/oyewoas/Documents/Software Dev Learning/With Companies/LevelUp Academy/Software Dev Projects/github/levelup-timeoffapp/src/components/FormValidator/FormValidator.js"],"names":["validator","FormValidator","validations","state","validation","valid","forEach","rule","field","isInvalid","field_value","toString","args","validation_method","method","validWhen","message","isValid","map"],"mappings":";;;;AAAA,OAAOA,SAAP,MAAsB,WAAtB;;IAEMC,a;;;AACJ,yBAAYC,WAAZ,EAAyB;AAAA;;AACvB;AACA,SAAKA,WAAL,GAAmBA,WAAnB;AACD;;;;6BAEQC,K,EAAO;AACd;AACA,UAAIC,UAAU,GAAG,KAAKC,KAAL,EAAjB,CAFc,CAId;;AACA,WAAKH,WAAL,CAAiBI,OAAjB,CAAyB,UAAAC,IAAI,EAAI;AAE/B;AACA,YAAI,CAACH,UAAU,CAACG,IAAI,CAACC,KAAN,CAAV,CAAuBC,SAA5B,EAAuC;AACrC;AACA;AACA,cAAMC,WAAW,GAAGP,KAAK,CAACI,IAAI,CAACC,KAAN,CAAL,CAAkBG,QAAlB,EAApB;AACA,cAAMC,IAAI,GAAGL,IAAI,CAACK,IAAL,IAAa,EAA1B;AACA,cAAMC,iBAAiB,GACjB,OAAON,IAAI,CAACO,MAAZ,KAAuB,QAAvB,GACAd,SAAS,CAACO,IAAI,CAACO,MAAN,CADT,GAEAP,IAAI,CAACO,MAHX,CALqC,CAUrC;AACA;AACA;AACA;AACA;;AACA,cAAGD,iBAAiB,MAAjB,UAAkBH,WAAlB,4BAAkCE,IAAlC,IAAwCT,KAAxC,QAAmDI,IAAI,CAACQ,SAA3D,EAAsE;AACpEX,YAAAA,UAAU,CAACG,IAAI,CAACC,KAAN,CAAV,GAAyB;AAAEC,cAAAA,SAAS,EAAE,IAAb;AAAmBO,cAAAA,OAAO,EAAET,IAAI,CAACS;AAAjC,aAAzB;AACAZ,YAAAA,UAAU,CAACa,OAAX,GAAqB,KAArB;AACD;AACF;AACF,OAvBD;AAyBA,aAAOb,UAAP;AACD;;;4BAEO;AACN,UAAMA,UAAU,GAAG,EAAnB;AAEA,WAAKF,WAAL,CAAiBgB,GAAjB,CAAqB,UAAAX,IAAI;AAAA,eACvBH,UAAU,CAACG,IAAI,CAACC,KAAN,CAAV,GAAyB;AAAEC,UAAAA,SAAS,EAAE,KAAb;AAAoBO,UAAAA,OAAO,EAAE;AAA7B,SADF;AAAA,OAAzB;AAIA;AAASC,QAAAA,OAAO,EAAE;AAAlB,SAA2Bb,UAA3B;AACD;;;;;;AAGH,eAAeH,aAAf","sourcesContent":["import validator from 'validator';\n\nclass FormValidator {\n  constructor(validations) {\n    // validations is an array of validation rules specific to a form\n    this.validations = validations;\n  }\n\n  validate(state) {\n    // start out assuming valid\n    let validation = this.valid();\n\n    // for each validation rule\n    this.validations.forEach(rule => {\n\n      // if the field hasn't already been marked invalid by an earlier rule\n      if (!validation[rule.field].isInvalid) {\n        // determine the field value, the method to invoke and optional args from \n        // the rule definition\n        const field_value = state[rule.field].toString();\n        const args = rule.args || [];\n        const validation_method = \n              typeof rule.method === 'string' ?\n              validator[rule.method] : \n              rule.method\n              \n        // call the validation_method with the current field value as the first\n        // argument, any additional arguments, and the whole state as a final\n        // argument.  If the result doesn't match the rule.validWhen property,\n        // then modify the validation object for the field and set the isValid\n        // field to false\n        if(validation_method(field_value, ...args, state) !== rule.validWhen) {\n          validation[rule.field] = { isInvalid: true, message: rule.message }\n          validation.isValid = false;\n        }\n      }\n    });\n\n    return validation;\n  }\n\n  valid() {\n    const validation = {}\n\n    this.validations.map(rule => (\n      validation[rule.field] = { isInvalid: false, message: '' }\n    ));\n\n    return { isValid: true, ...validation };\n  }\n}\n\nexport default FormValidator;"]},"metadata":{},"sourceType":"module"}